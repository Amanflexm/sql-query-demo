{"canmore.create_textdoc":{"name":"compliance_sql_queries","type":"document","content":"# Compliance Dashboard SQL Queries\n\nThis document contains a collection of SQL queries used to power compliance and risk monitoring dashboards. Each query is structured to support multi-tenant environments and designed for reporting on alerts, risk categories, periodic reviews, transactions, and regulatory reporting.\n\n---\n\n## 1. Total Alerts Query\nsql\nSELECT COUNT(*) AS total_alerts\nFROM alert\nWHERE tenant_id = %s;\n\nReturns the total number of alerts for a given tenant.\n\n---\n\n## 2. Expired Documents Query\nsql\nSELECT COUNT(document_id) AS expired_count\nFROM verification_documents\nWHERE tenant_id = %s\n AND document_status = 'ID Expired'\n AND document_expiry_date <= CURRENT_DATE;\n\nCounts expired verification documents for a tenant.\n\n---\n\n## 3. High Risk Customers Query\nsql\nSELECT COUNT(*) AS total_high_risk_customers\nFROM (\n SELECT cii.tenant_id, 'individual' AS customer_type, cii.id::text AS customer_id\n FROM customer_individual_identification cii\n WHERE cii.status <> 'Delete'\n AND cii.tenant_id = %s\n\n UNION ALL\n\n SELECT cei.tenant_id, 'entity' AS customer_type, cei.id::text AS customer_id\n FROM customer_entity_identification cei\n WHERE cei.status <> 'Delete'\n AND cei.tenant_id = %s\n) temp\nJOIN (\n SELECT DISTINCT ON (cs.customer_id)\n cs.customer_id, cs.customer_score_id, cs.tenant_id,\n csrr.final_risk_score::integer AS final_risk_score_int,\n csrr.risk_rate::integer AS risk_rate_int,\n csrr.customer_type, csrr.created_at AS score_created_at\n FROM customer_score cs\n JOIN customer_score_risk_rate csrr ON csrr.customer_score_id = cs.customer_score_id\n ORDER BY cs.customer_id, csrr.created_at DESC\n) cs_data ON cs_data.customer_id = temp.customer_id\nJOIN tenant_overall_risk_rates_settings tors_final\n ON tors_final.tenant_id = cs_data.tenant_id\n AND tors_final.customer_type = cs_data.customer_type\n AND tors_final.risk_rate = cs_data.risk_rate_int\nWHERE tors_final.default_risk_label IN ('H1', 'H2', 'H3');\n\nCounts customers labeled as high-risk.\n\n---\n\n## 4. Periodic Review Due Query\nsql\nWITH valid_customers AS (\n SELECT cii.id::text AS customer_id, 'individual' AS customer_type, cii.tenant_id\n FROM customer_individual_identification cii\n WHERE cii.status <> 'Delete'::customer_individual_identification_status_enum\n AND cii.tenant_id = %s\n\n UNION ALL\n\n SELECT cei.id::text AS customer_id, 'entity' AS customer_type, cei.tenant_id\n FROM customer_entity_identification cei\n WHERE cei.status <> 'Delete'::customer_entity_identification_status_enum\n AND cei.tenant_id = %s\n),\nranked_scores AS (\n SELECT cs.customer_id, cs.customer_type, cs.tenant_id, csrr.periodic_review_due,\n ROW_NUMBER() OVER (PARTITION BY cs.customer_id ORDER BY csrr.created_at DESC) AS row_num\n FROM customer_score cs\n JOIN customer_score_risk_rate csrr ON cs.customer_score_id = csrr.customer_score_id\n WHERE cs.tenant_id = %s\n),\neligible_scores AS (\n SELECT * FROM ranked_scores\n WHERE row_num = 1 AND periodic_review_due::date <= CURRENT_DATE\n)\nSELECT COUNT(DISTINCT es.customer_id) AS total_periodic_review_due_count\nFROM eligible_scores es\nJOIN valid_customers vc\n ON es.customer_id = vc.customer_id\n AND es.customer_type = vc.customer_type\n AND es.tenant_id = vc.tenant_id;\n\nCounts customers whose periodic review is due.\n\n---\n\n## 5. Transaction Monitor Overview Query\nsql\nSELECT TO_CHAR(DATE_TRUNC('month', t.flex_comply_date), 'Mon') AS month,\n EXTRACT(MONTH FROM t.flex_comply_date) AS month_num,\n pa.final_common_alert_result,\n COUNT(*) AS alert_count\nFROM transaction t\nJOIN transaction_monitoring_parent_alert pa ON t.parent_alert_id = pa.id\nWHERE t.flex_comply_date BETWEEN %s AND %s\n AND pa.final_common_alert_result IS NOT NULL\n AND t.tenant_id = %s\nGROUP BY TO_CHAR(DATE_TRUNC('month', t.flex_comply_date), 'Mon'),\n EXTRACT(MONTH FROM t.flex_comply_date),\n pa.final_common_alert_result\nORDER BY EXTRACT(MONTH FROM t.flex_comply_date), pa.final_common_alert_result;\n\nProvides monthly alert overview by alert result.\n\n---\n\n## 6. Alert Overview Query\nsql\nWITH selected_categories AS (\n SELECT 'Ongoing Monitoring Alert' AS category_name\n UNION ALL SELECT 'Onboarding Alert'\n UNION ALL SELECT 'Periodic Alert'\n),\nvalid_categories AS (\n SELECT id, category_name\n FROM category\n WHERE tenant_id = %s\n AND category_name IN ('Ongoing Monitoring Alert', 'Onboarding Alert', 'Periodic Alert')\n),\nalert_counts AS (\n SELECT vc.category_name, COUNT(a.id) AS alert_count\n FROM alert a\n JOIN valid_categories vc ON a.category_id = vc.id\n WHERE a.tenant_id = %s AND a.deleted_date IS NULL\n AND a.created_date BETWEEN %s AND %s\n GROUP BY vc.category_name\n)\nSELECT sc.category_name, COALESCE(ac.alert_count, 0) AS alert_count\nFROM selected_categories sc\nLEFT JOIN alert_counts ac ON sc.category_name = ac.category_name\nORDER BY sc.category_name;\n\nShows categorized alert overview (Ongoing, Onboarding, Periodic).\n\n---\n\n## 7–18. Other Queries\n- Regulatory Reports Filed Over Time → Monthly report filings grouped by type.\n- Risk Category Changes → Tracks customers moving from Low/Medium to High risk.\n- Transaction Volume by High Risk Customers → Monthly transaction counts & value.\n- Transaction Risk Categories Value → High/Medium/Low risk transaction value distribution.\n- Transactions in High Risk Countries → List & count of transactions with risky jurisdictions.\n- Transactions Involving High Risk Countries → Month-wise breakdown of volume/value.\n- TM Rule Mapped to Alert Status → Counts per rule & alert status.\n- True Positive Screening Matches → PEP & Sanctions true positive matches month-wise.\n- Regulatory Reporting Values → Monthly counts per report prefix.\n- High Risk Transaction Percentage → % share of high-risk transaction base amount.\n- No. of Alerts Triggered Monthwise → Rule-wise monthly alert counts.\n\n(Each query is structured in full in the source SQL definitions above.)\n\n---\n\n## Usage\n- Replace %s placeholders with the appropriate tenant_id, date ranges, or parameters.\n- Queries can be run directly in PostgreSQL or via ORM integration.\n- These queries are optimized for dashboards and compliance monitoring systems.\n\n---\n\n## Notes\n- Ensure correct timezone handling when filtering by dates.\n- Enum casts (e.g., ::customer_individual_identification_status_enum) may require schema-specific adjustments.\n- Queries are modular and can be adapted for reporting, APIs, or dashboards.\n\n---\n\n✅ This file serves as a reference guide for developers and analysts working with compliance dashboards."}}
